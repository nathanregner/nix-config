From 53b5e0fa6b6d31673f572a884eacb7f830c1b31f Mon Sep 17 00:00:00 2001
From: Sathya Pramodh <94102031+sathya-pramodh@users.noreply.github.com>
Date: Thu, 24 Jul 2025 08:15:31 +0530
Subject: [PATCH 7/9] feat: ":restart +cmd" #34788

Problem:
":restart" always executes ":qall" to exit the server.

Solution:
Support ":restart +cmd" so the user can control the command
used to exit the server.

Co-authored-by: Justin M. Keyes <justinkz@gmail.com>
Co-authored-by: zeertzjq <zeertzjq@outlook.com>
---
 src/nvim/ex_cmds.lua                  |  8 +++---
 src/nvim/ex_docmd.c                   | 41 +++++++++++++++++++++------
 src/nvim/globals.h                    |  2 ++
 src/nvim/main.c                       | 11 +++++++
 test/functional/terminal/tui_spec.lua | 39 ++++++++++++++-----------
 5 files changed, 72 insertions(+), 29 deletions(-)

diff --git a/src/nvim/ex_cmds.lua b/src/nvim/ex_cmds.lua
index a1ca1a30e4..180ffc32ef 100644
--- a/src/nvim/ex_cmds.lua
+++ b/src/nvim/ex_cmds.lua
@@ -2178,13 +2178,13 @@ M.cmds = {
     command = 'quitall',
     flags = bit.bor(BANG, TRLBAR),
     addr_type = 'ADDR_NONE',
-    func = 'ex_quitall_or_restart',
+    func = 'ex_quitall',
   },
   {
     command = 'qall',
     flags = bit.bor(BANG, TRLBAR, CMDWIN, LOCK_OK),
     addr_type = 'ADDR_NONE',
-    func = 'ex_quitall_or_restart',
+    func = 'ex_quitall',
   },
   {
     command = 'read',
@@ -2242,9 +2242,9 @@ M.cmds = {
   },
   {
     command = 'restart',
-    flags = bit.bor(BANG, TRLBAR),
+    flags = bit.bor(CMDARG, TRLBAR),
     addr_type = 'ADDR_NONE',
-    func = 'ex_quitall_or_restart',
+    func = 'ex_restart',
   },
   {
     command = 'retab',
diff --git a/src/nvim/ex_docmd.c b/src/nvim/ex_docmd.c
index 2dfafa8cca..11ea2f4092 100644
--- a/src/nvim/ex_docmd.c
+++ b/src/nvim/ex_docmd.c
@@ -15,6 +15,7 @@
 #include "nvim/api/private/defs.h"
 #include "nvim/api/private/helpers.h"
 #include "nvim/api/ui.h"
+#include "nvim/api/vimscript.h"
 #include "nvim/arglist.h"
 #include "nvim/ascii_defs.h"
 #include "nvim/autocmd.h"
@@ -4704,6 +4705,13 @@ void not_exiting(void)
   exiting = false;
 }
 
+/// Call this function if we thought we were going to restart, but we won't
+/// (because of an error).
+void not_restarting(void)
+{
+  restarting = false;
+}
+
 bool before_quit_autocmds(win_T *wp, bool quit_all, bool forceit)
 {
   apply_autocmds(EVENT_QUITPRE, NULL, NULL, false, wp->w_buffer);
@@ -4833,22 +4841,39 @@ int before_quit_all(exarg_T *eap)
 }
 
 /// ":qall": try to quit all windows
-/// ":restart": restart the Nvim server
-static void ex_quitall_or_restart(exarg_T *eap)
+static void ex_quitall(exarg_T *eap)
 {
   if (before_quit_all(eap) == FAIL) {
     return;
   }
   exiting = true;
-  Error err = ERROR_INIT;
-  if ((eap->forceit || !check_changed_any(false, false))
-      && (eap->cmdidx != CMD_restart || remote_ui_restart(current_ui, &err))) {
-    getout(0);
+  if (!eap->forceit && check_changed_any(false, false)) {
+    not_exiting();
+    return;
   }
-  not_exiting();
+  getout(0);
+}
+
+/// ":restart": restart the Nvim server (using ":qall!").
+/// ":restart +cmd": restart the Nvim server using ":cmd".
+static void ex_restart(exarg_T *eap)
+{
+  char *quit_cmd = (eap->do_ecmd_cmd) ? eap->do_ecmd_cmd : "qall!";
+  Error err = ERROR_INIT;
+  if ((cmdmod.cmod_flags & CMOD_CONFIRM) && check_changed_any(false, false)) {
+    return;
+  }
+  restarting = true;
+  nvim_command(cstr_as_string(quit_cmd), &err);
   if (ERROR_SET(&err)) {
-    emsg(err.msg);  // UI disappeared already?
+    emsg(err.msg);  // Could not exit
     api_clear_error(&err);
+    not_restarting();
+    return;
+  }
+  if (!exiting) {
+    emsg("restart failed: +cmd did not quit the server");
+    not_restarting();
   }
 }
 
diff --git a/src/nvim/globals.h b/src/nvim/globals.h
index 15152bc1a4..b14d5babbb 100644
--- a/src/nvim/globals.h
+++ b/src/nvim/globals.h
@@ -423,6 +423,8 @@ EXTERN int sc_col;              // column for shown command
 EXTERN int starting INIT( = NO_SCREEN);
 // true when planning to exit. Might keep running if there is a changed buffer.
 EXTERN bool exiting INIT( = false);
+// true when planning to restart.
+EXTERN bool restarting INIT( = false);
 // internal value of v:dying
 EXTERN int v_dying INIT( = 0);
 // is stdin a terminal?
diff --git a/src/nvim/main.c b/src/nvim/main.c
index b7faa59e6b..405e1dad2a 100644
--- a/src/nvim/main.c
+++ b/src/nvim/main.c
@@ -806,6 +806,17 @@ void getout(int exitval)
     ui_call_set_title(cstr_as_string(p_titleold));
   }
 
+  if (restarting) {
+    Error err = ERROR_INIT;
+    if (!remote_ui_restart(current_ui, &err)) {
+      if (ERROR_SET(&err)) {
+        ELOG("%s", err.msg);  // UI disappeared already?
+        api_clear_error(&err);
+      }
+    }
+    restarting = false;
+  }
+
   if (garbage_collect_at_exit) {
     garbage_collect(false);
   }
diff --git a/test/functional/terminal/tui_spec.lua b/test/functional/terminal/tui_spec.lua
index 9949bb31a6..ef171b3e06 100644
--- a/test/functional/terminal/tui_spec.lua
+++ b/test/functional/terminal/tui_spec.lua
@@ -264,6 +264,16 @@ describe('TUI :restart', function()
     restart_pid_check()
     gui_running_check()
 
+    -- Check ":restart +qall" on an unmodified buffer.
+    tt.feed_data(':restart +qall\013')
+    screen_expect(s0)
+    restart_pid_check()
+    gui_running_check()
+
+    -- Check ":restart +echo" cannot restart server.
+    tt.feed_data(':restart +echo\013')
+    screen:expect({ any = vim.pesc('+cmd did not quit the server') })
+
     tt.feed_data('ithis will be removed\027')
     screen_expect([[
       this will be remove^d                              |
@@ -273,20 +283,15 @@ describe('TUI :restart', function()
       {3:-- TERMINAL --}                                    |
     ]])
 
-    -- Check ":restart" on a modified buffer.
-    tt.feed_data(':restart\013')
-    screen_expect([[
-      this will be removed                              |
-      {5:                                                  }|
-      {8:E37: No write since last change}                   |
-      {8:E162: No write since last change for buffer "[No N}|
-      {8:ame]"}                                             |
-      {10:Press ENTER or type command to continue}^           |
-      {3:-- TERMINAL --}                                    |
-    ]])
+    -- Check ":confirm restart" on a modified buffer.
+    tt.feed_data(':confirm restart\013')
+    screen:expect({ any = vim.pesc('Save changes to "Untitled"?') })
 
-    -- Check ":restart!".
-    tt.feed_data(':restart!\013')
+    -- Cancel the operation (abandons restart).
+    tt.feed_data('C\013')
+
+    -- Check ":restart" on the modified buffer.
+    tt.feed_data(':restart\013')
     screen_expect(s0)
     restart_pid_check()
     gui_running_check()
@@ -3770,9 +3775,9 @@ describe('TUI client', function()
     screen_client:expect(s1)
     screen_server:expect(s1)
 
-    -- Run :restart! on the remote client.
+    -- Run :restart on the remote client.
     -- The remote client should start a new server while the original one should exit.
-    feed_data(':restart!\n')
+    feed_data(':restart\n')
     screen_client:expect([[
       ^                                                  |
       {4:~                                                 }|*3
@@ -3847,9 +3852,9 @@ describe('TUI client', function()
     feed_data(':echo "GUI Running: " .. has("gui_running")\013')
     screen_client:expect({ any = 'GUI Running: 1' })
 
-    -- Run :restart! on the client.
+    -- Run :restart on the client.
     -- The client should start a new server while the original server should exit.
-    feed_data(':restart!\n')
+    feed_data(':restart\n')
     screen_client:expect([[
       ^                                                  |
       {4:~                                                 }|*4
-- 
2.51.0

