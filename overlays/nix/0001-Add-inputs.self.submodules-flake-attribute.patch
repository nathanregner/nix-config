From 2d449de8478b3fe1af18ac202ee01bf73d32ccac Mon Sep 17 00:00:00 2001
From: Eelco Dolstra <edolstra@gmail.com>
Date: Tue, 4 Feb 2025 20:51:14 +0100
Subject: [PATCH] Add `inputs.self.submodules` flake attribute

This allows a flake to specify that it needs Git submodules to be
enabled (or disabled, if we ever change the default) on the top-level
flake. This requires the input to be refetched, but since the first
fetch is lazy, this shouldn't be expensive.

Currently the only attribute allowed by `inputs.self` is `submodules`,
but more can be added in the future (e.g. a `lazy` attribute to opt in
to lazy tree behaviour).

Fixes #5312, #9842.
---
 src/libflake/flake/flake.cc                   | 509 ++++++++++--------
 src/libflake/flake/flake.hh                   |  15 +-
 tests/functional/flakes/flake-in-submodule.sh |  14 +
 3 files changed, 309 insertions(+), 229 deletions(-)

diff --git a/src/libflake/flake/flake.cc b/src/libflake/flake/flake.cc
index edb76f8615..6cfe527b93 100644
--- a/src/libflake/flake/flake.cc
+++ b/src/libflake/flake/flake.cc
@@ -24,15 +24,12 @@ namespace flake {
 typedef std::pair<StorePath, FlakeRef> FetchedFlake;
 typedef std::vector<std::pair<FlakeRef, FetchedFlake>> FlakeCache;
 
-static std::optional<FetchedFlake> lookupInFlakeCache(
-    const FlakeCache & flakeCache,
-    const FlakeRef & flakeRef)
+static std::optional<FetchedFlake> lookupInFlakeCache(const FlakeCache & flakeCache, const FlakeRef & flakeRef)
 {
     // FIXME: inefficient.
     for (auto & i : flakeCache) {
         if (flakeRef == i.first) {
-            debug("mapping '%s' to previously seen input '%s' -> '%s",
-                flakeRef, i.first, i.second.second);
+            debug("mapping '%s' to previously seen input '%s' -> '%s", flakeRef, i.first, i.second.second);
             return i.second;
         }
     }
@@ -40,11 +37,8 @@ static std::optional<FetchedFlake> lookupInFlakeCache(
     return std::nullopt;
 }
 
-static std::tuple<StorePath, FlakeRef, FlakeRef> fetchOrSubstituteTree(
-    EvalState & state,
-    const FlakeRef & originalRef,
-    bool allowLookup,
-    FlakeCache & flakeCache)
+static std::tuple<StorePath, FlakeRef, FlakeRef>
+fetchOrSubstituteTree(EvalState & state, const FlakeRef & originalRef, bool allowLookup, FlakeCache & flakeCache)
 {
     auto fetched = lookupInFlakeCache(flakeCache, originalRef);
     FlakeRef resolvedRef = originalRef;
@@ -56,11 +50,11 @@ static std::tuple<StorePath, FlakeRef, FlakeRef> fetchOrSubstituteTree(
             if (allowLookup) {
                 resolvedRef = originalRef.resolve(state.store);
                 auto fetchedResolved = lookupInFlakeCache(flakeCache, originalRef);
-                if (!fetchedResolved) fetchedResolved.emplace(resolvedRef.fetchTree(state.store));
+                if (!fetchedResolved)
+                    fetchedResolved.emplace(resolvedRef.fetchTree(state.store));
                 flakeCache.push_back({resolvedRef, *fetchedResolved});
                 fetched.emplace(*fetchedResolved);
-            }
-            else {
+            } else {
                 throw Error("'%s' is an indirect flake reference, but registry lookups are not allowed", originalRef);
             }
         }
@@ -69,8 +63,7 @@ static std::tuple<StorePath, FlakeRef, FlakeRef> fetchOrSubstituteTree(
 
     auto [storePath, lockedRef] = *fetched;
 
-    debug("got tree '%s' from '%s'",
-        state.store->printStorePath(storePath), lockedRef);
+    debug("got tree '%s' from '%s'", state.store->printStorePath(storePath), lockedRef);
 
     state.allowPath(storePath);
 
@@ -85,22 +78,67 @@ static void forceTrivialValue(EvalState & state, Value & value, const PosIdx pos
         state.forceValue(value, pos);
 }
 
-static void expectType(EvalState & state, ValueType type,
-    Value & value, const PosIdx pos)
+static void expectType(EvalState & state, ValueType type, Value & value, const PosIdx pos)
 {
     forceTrivialValue(state, value, pos);
     if (value.type() != type)
-        throw Error("expected %s but got %s at %s",
-            showType(type), showType(value.type()), state.positions[pos]);
+        throw Error("expected %s but got %s at %s", showType(type), showType(value.type()), state.positions[pos]);
 }
 
-static std::map<FlakeId, FlakeInput> parseFlakeInputs(
-    EvalState & state, Value * value, const PosIdx pos,
-    const std::optional<Path> & baseDir, InputPath lockRootPath);
+static std::pair<std::map<FlakeId, FlakeInput>, fetchers::Attrs> parseFlakeInputs(
+    EvalState & state,
+    Value * value,
+    const PosIdx pos,
+    const InputAttrPath & lockRootAttrPath,
+    const SourcePath & flakeDir,
+    bool allowSelf);
 
-static FlakeInput parseFlakeInput(EvalState & state,
-    std::string_view inputName, Value * value, const PosIdx pos,
-    const std::optional<Path> & baseDir, InputPath lockRootPath)
+static void parseFlakeInputAttr(EvalState & state, const Attr & attr, fetchers::Attrs & attrs)
+{
+// Allow selecting a subset of enum values
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wswitch-enum"
+    switch (attr.value->type()) {
+    case nString:
+        attrs.emplace(state.symbols[attr.name], attr.value->c_str());
+        break;
+    case nBool:
+        attrs.emplace(state.symbols[attr.name], Explicit<bool>{attr.value->boolean()});
+        break;
+    case nInt: {
+        auto intValue = attr.value->integer().value;
+        if (intValue < 0)
+            state
+                .error<EvalError>(
+                    "negative value given for flake input attribute %1%: %2%", state.symbols[attr.name], intValue)
+                .debugThrow();
+        attrs.emplace(state.symbols[attr.name], uint64_t(intValue));
+        break;
+    }
+    default:
+        if (attr.name == state.symbols.create("publicKeys")) {
+            experimentalFeatureSettings.require(Xp::VerifiedFetches);
+            NixStringContext emptyContext = {};
+            attrs.emplace(
+                state.symbols[attr.name], printValueAsJSON(state, true, *attr.value, attr.pos, emptyContext).dump());
+        } else
+            state
+                .error<TypeError>(
+                    "flake input attribute '%s' is %s while a string, Boolean, or integer is expected",
+                    state.symbols[attr.name],
+                    showType(*attr.value))
+                .debugThrow();
+    }
+#pragma GCC diagnostic pop
+}
+
+static FlakeInput parseFlakeInput(
+    EvalState & state,
+    std::string_view inputName,
+    Value * value,
+    const PosIdx pos,
+    const std::optional<Path> & baseDir,
+    InputPath lockRootPath)
 {
     expectType(state, nAttrs, *value, pos);
 
@@ -124,48 +162,18 @@ static FlakeInput parseFlakeInput(EvalState & state,
                 expectType(state, nBool, *attr.value, attr.pos);
                 input.isFlake = attr.value->boolean();
             } else if (attr.name == sInputs) {
-                input.overrides = parseFlakeInputs(state, attr.value, attr.pos, baseDir, lockRootPath);
+                input.overrides =
+                    parseFlakeInputs(state, attr.value, attr.pos, lockRootAttrPath, flakeDir, false).first;
             } else if (attr.name == sFollows) {
                 expectType(state, nString, *attr.value, attr.pos);
                 auto follows(parseInputPath(attr.value->c_str()));
                 follows.insert(follows.begin(), lockRootPath.begin(), lockRootPath.end());
                 input.follows = follows;
-            } else {
-                // Allow selecting a subset of enum values
-                #pragma GCC diagnostic push
-                #pragma GCC diagnostic ignored "-Wswitch-enum"
-                switch (attr.value->type()) {
-                    case nString:
-                        attrs.emplace(state.symbols[attr.name], attr.value->c_str());
-                        break;
-                    case nBool:
-                        attrs.emplace(state.symbols[attr.name], Explicit<bool> { attr.value->boolean() });
-                        break;
-                    case nInt: {
-                        auto intValue = attr.value->integer().value;
-
-                        if (intValue < 0) {
-                            state.error<EvalError>("negative value given for flake input attribute %1%: %2%", state.symbols[attr.name], intValue).debugThrow();
-                        }
-
-                        attrs.emplace(state.symbols[attr.name], uint64_t(intValue));
-                        break;
-                    }
-                    default:
-                        if (attr.name == state.symbols.create("publicKeys")) {
-                            experimentalFeatureSettings.require(Xp::VerifiedFetches);
-                            NixStringContext emptyContext = {};
-                            attrs.emplace(state.symbols[attr.name], printValueAsJSON(state, true, *attr.value, pos, emptyContext).dump());
-                        } else
-                            state.error<TypeError>("flake input attribute '%s' is %s while a string, Boolean, or integer is expected",
-                                state.symbols[attr.name], showType(*attr.value)).debugThrow();
-                }
-                #pragma GCC diagnostic pop
-            }
+            } else
+                parseFlakeInputAttr(state, attr, attrs);
         } catch (Error & e) {
             e.addTrace(
-                state.positions[attr.pos],
-                HintFmt("while evaluating flake attribute '%s'", state.symbols[attr.name]));
+                state.positions[attr.pos], HintFmt("while evaluating flake attribute '%s'", state.symbols[attr.name]));
             throw;
         }
     }
@@ -191,25 +199,35 @@ static FlakeInput parseFlakeInput(EvalState & state,
     return input;
 }
 
-static std::map<FlakeId, FlakeInput> parseFlakeInputs(
-    EvalState & state, Value * value, const PosIdx pos,
-    const std::optional<Path> & baseDir, InputPath lockRootPath)
+static std::pair<std::map<FlakeId, FlakeInput>, fetchers::Attrs> parseFlakeInputs(
+    EvalState & state,
+    Value * value,
+    const PosIdx pos,
+    const InputAttrPath & lockRootAttrPath,
+    const SourcePath & flakeDir,
+    bool allowSelf)
 {
     std::map<FlakeId, FlakeInput> inputs;
+    fetchers::Attrs selfAttrs;
 
     expectType(state, nAttrs, *value, pos);
 
     for (auto & inputAttr : *value->attrs()) {
-        inputs.emplace(state.symbols[inputAttr.name],
-            parseFlakeInput(state,
-                state.symbols[inputAttr.name],
-                inputAttr.value,
-                inputAttr.pos,
-                baseDir,
-                lockRootPath));
+        auto inputName = state.symbols[inputAttr.name];
+        if (inputName == "self") {
+            if (!allowSelf)
+                throw Error("'self' input attribute not allowed at %s", state.positions[inputAttr.pos]);
+            expectType(state, nAttrs, *inputAttr.value, inputAttr.pos);
+            for (auto & attr : *inputAttr.value->attrs())
+                parseFlakeInputAttr(state, attr, selfAttrs);
+        } else {
+            inputs.emplace(
+                inputName,
+                parseFlakeInput(state, inputName, inputAttr.value, inputAttr.pos, lockRootAttrPath, flakeDir));
+        }
     }
 
-    return inputs;
+    return {inputs, selfAttrs};
 }
 
 static Flake readFlake(
@@ -226,7 +244,7 @@ static Flake readFlake(
     Value vInfo;
     state.evalFile(flakePath, vInfo, true);
 
-    Flake flake {
+    Flake flake{
         .originalRef = originalRef,
         .resolvedRef = resolvedRef,
         .lockedRef = lockedRef,
@@ -240,8 +258,12 @@ static Flake readFlake(
 
     auto sInputs = state.symbols.create("inputs");
 
-    if (auto inputs = vInfo.attrs()->get(sInputs))
-        flake.inputs = parseFlakeInputs(state, inputs->value, inputs->pos, flakePath.parent().path.abs(), lockRootPath); // FIXME
+    if (auto inputs = vInfo.attrs()->get(sInputs)) {
+        auto [flakeInputs, selfAttrs] =
+            parseFlakeInputs(state, inputs->value, inputs->pos, lockRootAttrPath, flakeDir, true);
+        flake.inputs = std::move(flakeInputs);
+        flake.selfAttrs = std::move(selfAttrs);
+    }
 
     auto sOutputs = state.symbols.create("outputs");
 
@@ -251,9 +273,9 @@ static Flake readFlake(
         if (outputs->value->isLambda() && outputs->value->payload.lambda.fun->hasFormals()) {
             for (auto & formal : outputs->value->payload.lambda.fun->formals->formals) {
                 if (formal.name != state.sSelf)
-                    flake.inputs.emplace(state.symbols[formal.name], FlakeInput {
-                        .ref = parseFlakeRef(state.fetchSettings, std::string(state.symbols[formal.name]))
-                    });
+                    flake.inputs.emplace(
+                        state.symbols[formal.name],
+                        FlakeInput{.ref = parseFlakeRef(state.fetchSettings, std::string(state.symbols[formal.name]))});
             }
         }
 
@@ -269,61 +291,97 @@ static Flake readFlake(
             forceTrivialValue(state, *setting.value, setting.pos);
             if (setting.value->type() == nString)
                 flake.config.settings.emplace(
-                    state.symbols[setting.name],
-                    std::string(state.forceStringNoCtx(*setting.value, setting.pos, "")));
+                    state.symbols[setting.name], std::string(state.forceStringNoCtx(*setting.value, setting.pos, "")));
             else if (setting.value->type() == nPath) {
                 NixStringContext emptyContext = {};
                 flake.config.settings.emplace(
                     state.symbols[setting.name],
                     state.coerceToString(setting.pos, *setting.value, emptyContext, "", false, true, true).toOwned());
-            }
-            else if (setting.value->type() == nInt)
+            } else if (setting.value->type() == nInt)
                 flake.config.settings.emplace(
-                    state.symbols[setting.name],
-                    state.forceInt(*setting.value, setting.pos, "").value);
+                    state.symbols[setting.name], state.forceInt(*setting.value, setting.pos, "").value);
             else if (setting.value->type() == nBool)
                 flake.config.settings.emplace(
-                    state.symbols[setting.name],
-                    Explicit<bool> { state.forceBool(*setting.value, setting.pos, "") });
+                    state.symbols[setting.name], Explicit<bool>{state.forceBool(*setting.value, setting.pos, "")});
             else if (setting.value->type() == nList) {
                 std::vector<std::string> ss;
                 for (auto elem : setting.value->listItems()) {
                     if (elem->type() != nString)
-                        state.error<TypeError>("list element in flake configuration setting '%s' is %s while a string is expected",
-                            state.symbols[setting.name], showType(*setting.value)).debugThrow();
+                        state
+                            .error<TypeError>(
+                                "list element in flake configuration setting '%s' is %s while a string is expected",
+                                state.symbols[setting.name],
+                                showType(*setting.value))
+                            .debugThrow();
                     ss.emplace_back(state.forceStringNoCtx(*elem, setting.pos, ""));
                 }
                 flake.config.settings.emplace(state.symbols[setting.name], ss);
-            }
-            else
-                state.error<TypeError>("flake configuration setting '%s' is %s",
-                    state.symbols[setting.name], showType(*setting.value)).debugThrow();
+            } else
+                state
+                    .error<TypeError>(
+                        "flake configuration setting '%s' is %s", state.symbols[setting.name], showType(*setting.value))
+                    .debugThrow();
         }
     }
 
     for (auto & attr : *vInfo.attrs()) {
-        if (attr.name != state.sDescription &&
-            attr.name != sInputs &&
-            attr.name != sOutputs &&
-            attr.name != sNixConfig)
-            throw Error("flake '%s' has an unsupported attribute '%s', at %s",
-                resolvedRef, state.symbols[attr.name], state.positions[attr.pos]);
+        if (attr.name != state.sDescription && attr.name != sInputs && attr.name != sOutputs && attr.name != sNixConfig)
+            throw Error(
+                "flake '%s' has an unsupported attribute '%s', at %s",
+                resolvedRef,
+                state.symbols[attr.name],
+                state.positions[attr.pos]);
     }
 
     return flake;
 }
 
-static Flake getFlake(
-    EvalState & state,
-    const FlakeRef & originalRef,
-    bool allowLookup,
-    FlakeCache & flakeCache,
-    InputPath lockRootPath)
+static FlakeRef applySelfAttrs(const FlakeRef & ref, const Flake & flake)
 {
-    auto [storePath, resolvedRef, lockedRef] = fetchOrSubstituteTree(
-        state, originalRef, allowLookup, flakeCache);
+    auto newRef(ref);
 
-    return readFlake(state, originalRef, resolvedRef, lockedRef, state.rootPath(state.store->toRealPath(storePath)), lockRootPath);
+    std::set<std::string> allowedAttrs{"submodules"};
+
+    for (auto & attr : flake.selfAttrs) {
+        if (!allowedAttrs.contains(attr.first))
+            throw Error("flake 'self' attribute '%s' is not supported", attr.first);
+        newRef.input.attrs.insert_or_assign(attr.first, attr.second);
+    }
+
+    return newRef;
+}
+
+static Flake getFlake(
+    EvalState & state, const FlakeRef & originalRef, bool allowLookup, FlakeCache & flakeCache, InputPath lockRootPath)
+{
+    auto [storePath, resolvedRef, lockedRef] = fetchOrSubstituteTree(state, originalRef, allowLookup, flakeCache);
+
+    // Parse/eval flake.nix to get at the input.self attributes.
+    auto flake = readFlake(state, originalRef, resolvedRef, lockedRef, {accessor}, lockRootAttrPath);
+
+    // Re-fetch the tree if necessary.
+    auto newLockedRef = applySelfAttrs(lockedRef, flake);
+
+    if (lockedRef != newLockedRef) {
+        debug("refetching input '%s' due to self attribute", newLockedRef);
+        // FIXME: need to remove attrs that are invalidated by the changed input attrs, such as 'narHash'.
+        newLockedRef.input.attrs.erase("narHash");
+        auto [accessor2, resolvedRef2, lockedRef2] = fetchOrSubstituteTree(state, newLockedRef, false, flakeCache);
+        accessor = accessor2;
+        lockedRef = lockedRef2;
+    }
+
+    // Copy the tree to the store.
+    auto storePath = copyInputToStore(state, lockedRef.input, accessor);
+
+    // Re-parse flake.nix from the store.
+    return readFlake(
+        state,
+        originalRef,
+        resolvedRef,
+        lockedRef,
+        state.rootPath(state.store->toRealPath(storePath)),
+        lockRootAttrPath);
 }
 
 Flake getFlake(EvalState & state, const FlakeRef & originalRef, bool allowLookup, FlakeCache & flakeCache)
@@ -337,22 +395,16 @@ Flake getFlake(EvalState & state, const FlakeRef & originalRef, bool allowLookup
     return getFlake(state, originalRef, allowLookup, flakeCache);
 }
 
-static LockFile readLockFile(
-    const fetchers::Settings & fetchSettings,
-    const SourcePath & lockFilePath)
+static LockFile readLockFile(const fetchers::Settings & fetchSettings, const SourcePath & lockFilePath)
 {
-    return lockFilePath.pathExists()
-        ? LockFile(fetchSettings, lockFilePath.readFile(), fmt("%s", lockFilePath))
-        : LockFile();
+    return lockFilePath.pathExists() ? LockFile(fetchSettings, lockFilePath.readFile(), fmt("%s", lockFilePath))
+                                     : LockFile();
 }
 
 /* Compute an in-memory lock file for the specified top-level flake,
    and optionally write it to file, if the flake is writable. */
-LockedFlake lockFlake(
-    const Settings & settings,
-    EvalState & state,
-    const FlakeRef & topRef,
-    const LockFlags & lockFlags)
+LockedFlake
+lockFlake(const Settings & settings, EvalState & state, const FlakeRef & topRef, const LockFlags & lockFlags)
 {
     experimentalFeatureSettings.require(Xp::Flakes);
 
@@ -372,10 +424,8 @@ LockedFlake lockFlake(
             throw Error("reference lock file was provided, but the `allow-dirty` setting is set to false");
         }
 
-        auto oldLockFile = readLockFile(
-            state.fetchSettings,
-            lockFlags.referenceLockFilePath.value_or(
-                flake.lockFilePath()));
+        auto oldLockFile =
+            readLockFile(state.fetchSettings, lockFlags.referenceLockFilePath.value_or(flake.lockFilePath()));
 
         debug("old lock file: %s", oldLockFile);
 
@@ -385,7 +435,7 @@ LockedFlake lockFlake(
         std::map<ref<Node>, SourcePath> nodePaths;
 
         for (auto & i : lockFlags.inputOverrides) {
-            overrides.insert_or_assign(i.first, FlakeInput { .ref = i.second });
+            overrides.insert_or_assign(i.first, FlakeInput{.ref = i.second});
             explicitCliOverrides.insert(i.first);
         }
 
@@ -404,25 +454,25 @@ LockedFlake lockFlake(
             computeLocks;
 
         computeLocks = [&](
-            /* The inputs of this node, either from flake.nix or
-               flake.lock. */
-            const FlakeInputs & flakeInputs,
-            /* The node whose locks are to be updated.*/
-            ref<Node> node,
-            /* The path to this node in the lock file graph. */
-            const InputPath & inputPathPrefix,
-            /* The old node, if any, from which locks can be
-               copied. */
-            std::shared_ptr<const Node> oldNode,
-            const InputPath & lockRootPath,
-            const Path & parentPath,
-            bool trustLock)
-        {
+                           /* The inputs of this node, either from flake.nix or
+                              flake.lock. */
+                           const FlakeInputs & flakeInputs,
+                           /* The node whose locks are to be updated.*/
+                           ref<Node> node,
+                           /* The path to this node in the lock file graph. */
+                           const InputPath & inputPathPrefix,
+                           /* The old node, if any, from which locks can be
+                              copied. */
+                           std::shared_ptr<const Node> oldNode,
+                           const InputPath & lockRootPath,
+                           const Path & parentPath,
+                           bool trustLock) {
             debug("computing lock file node '%s'", printInputPath(inputPathPrefix));
 
             /* Get the overrides (i.e. attributes of the form
                'inputs.nixops.inputs.nixpkgs.url = ...'). */
             for (auto & [id, input] : flakeInputs) {
+                // if (id == "self") continue;
                 for (auto & [idOverride, inputOverride] : input.overrides) {
                     auto inputPath(inputPathPrefix);
                     inputPath.push_back(id);
@@ -440,7 +490,8 @@ LockedFlake lockFlake(
                 if (inputPath2 == inputPathPrefix && !flakeInputs.count(follow))
                     warn(
                         "input '%s' has an override for a non-existent input '%s'",
-                        printInputPath(inputPathPrefix), follow);
+                        printInputPath(inputPathPrefix),
+                        follow);
             }
 
             /* Go over the flake inputs, resolve/fetch them if
@@ -492,17 +543,14 @@ LockedFlake lockFlake(
                             if (auto oldLock3 = std::get_if<0>(&*oldLock2))
                                 oldLock = *oldLock3;
 
-                    if (oldLock
-                        && oldLock->originalRef == *input.ref
-                        && !hasCliOverride)
-                    {
+                    if (oldLock && oldLock->originalRef == *input.ref && !hasCliOverride) {
                         debug("keeping existing input '%s'", inputPathS);
 
                         /* Copy the input from the old lock since its flakeref
                            didn't change and there is no override from a
                            higher level flake. */
-                        auto childNode = make_ref<LockedNode>(
-                            oldLock->lockedRef, oldLock->originalRef, oldLock->isFlake);
+                        auto childNode =
+                            make_ref<LockedNode>(oldLock->lockedRef, oldLock->originalRef, oldLock->isFlake);
 
                         node->inputs.insert_or_assign(id, childNode);
 
@@ -510,10 +558,8 @@ LockedFlake lockFlake(
                            must fetch the flake to update it. */
                         auto lb = lockFlags.inputUpdates.lower_bound(inputPath);
 
-                        auto mustRefetch =
-                            lb != lockFlags.inputUpdates.end()
-                            && lb->size() > inputPath.size()
-                            && std::equal(inputPath.begin(), inputPath.end(), lb->begin());
+                        auto mustRefetch = lb != lockFlags.inputUpdates.end() && lb->size() > inputPath.size()
+                                           && std::equal(inputPath.begin(), inputPath.end(), lb->begin());
 
                         FlakeInputs fakeInputs;
 
@@ -524,14 +570,17 @@ LockedFlake lockFlake(
                                those. */
                             for (auto & i : oldLock->inputs) {
                                 if (auto lockedNode = std::get_if<0>(&i.second)) {
-                                    fakeInputs.emplace(i.first, FlakeInput {
-                                        .ref = (*lockedNode)->originalRef,
-                                        .isFlake = (*lockedNode)->isFlake,
-                                    });
+                                    fakeInputs.emplace(
+                                        i.first,
+                                        FlakeInput{
+                                            .ref = (*lockedNode)->originalRef,
+                                            .isFlake = (*lockedNode)->isFlake,
+                                        });
                                 } else if (auto follows = std::get_if<1>(&i.second)) {
                                     if (!trustLock) {
                                         // It is possible that the flake has changed,
-                                        // so we must confirm all the follows that are in the lock file are also in the flake.
+                                        // so we must confirm all the follows that are in the lock file are also in the
+                                        // flake.
                                         auto overridePath(inputPath);
                                         overridePath.push_back(i.first);
                                         auto o = overrides.find(overridePath);
@@ -546,9 +595,11 @@ LockedFlake lockFlake(
                                     }
                                     auto absoluteFollows(lockRootPath);
                                     absoluteFollows.insert(absoluteFollows.end(), follows->begin(), follows->end());
-                                    fakeInputs.emplace(i.first, FlakeInput {
-                                        .follows = absoluteFollows,
-                                    });
+                                    fakeInputs.emplace(
+                                        i.first,
+                                        FlakeInput{
+                                            .follows = absoluteFollows,
+                                        });
                                 }
                             }
                         }
@@ -556,7 +607,8 @@ LockedFlake lockFlake(
                         if (mustRefetch) {
                             auto inputFlake = getFlake(state, oldLock->lockedRef, false, flakeCache, inputPath);
                             nodePaths.emplace(childNode, inputFlake.path.parent());
-                            computeLocks(inputFlake.inputs, childNode, inputPath, oldLock, lockRootPath, parentPath, false);
+                            computeLocks(
+                                inputFlake.inputs, childNode, inputPath, oldLock, lockRootPath, parentPath, false);
                         } else {
                             computeLocks(fakeInputs, childNode, inputPath, oldLock, lockRootPath, parentPath, true);
                         }
@@ -606,18 +658,19 @@ LockedFlake lockFlake(
                                own lock file. */
                             nodePaths.emplace(childNode, inputFlake.path.parent());
                             computeLocks(
-                                inputFlake.inputs, childNode, inputPath,
-                                oldLock
-                                ? std::dynamic_pointer_cast<const Node>(oldLock)
-                                : readLockFile(state.fetchSettings, inputFlake.lockFilePath()).root.get_ptr(),
+                                inputFlake.inputs,
+                                childNode,
+                                inputPath,
+                                oldLock ? std::dynamic_pointer_cast<const Node>(oldLock)
+                                        : readLockFile(state.fetchSettings, inputFlake.lockFilePath()).root.get_ptr(),
                                 oldLock ? lockRootPath : inputPath,
                                 localPath,
                                 false);
                         }
 
                         else {
-                            auto [storePath, resolvedRef, lockedRef] = fetchOrSubstituteTree(
-                                state, *input.ref, useRegistries, flakeCache);
+                            auto [storePath, resolvedRef, lockedRef] =
+                                fetchOrSubstituteTree(state, *input.ref, useRegistries, flakeCache);
 
                             auto childNode = make_ref<LockedNode>(lockedRef, ref, false);
 
@@ -650,8 +703,7 @@ LockedFlake lockFlake(
 
         for (auto & i : lockFlags.inputOverrides)
             if (!overridesUsed.count(i.first))
-                warn("the flag '--override-input %s %s' does not match any input",
-                    printInputPath(i.first), i.second);
+                warn("the flag '--override-input %s %s' does not match any input", printInputPath(i.first), i.second);
 
         for (auto & i : lockFlags.inputUpdates)
             if (!updatesUsed.count(i))
@@ -673,10 +725,15 @@ LockedFlake lockFlake(
                 if (sourcePath || lockFlags.outputLockFilePath) {
                     if (auto unlockedInput = newLockFile.isUnlocked()) {
                         if (state.fetchSettings.warnDirty)
-                            warn("will not write lock file of flake '%s' because it has an unlocked input ('%s')", topRef, *unlockedInput);
+                            warn(
+                                "will not write lock file of flake '%s' because it has an unlocked input ('%s')",
+                                topRef,
+                                *unlockedInput);
                     } else {
                         if (!lockFlags.updateLockFile)
-                            throw Error("flake '%s' requires lock file changes but they're not allowed due to '--no-update-lock-file'", topRef);
+                            throw Error(
+                                "flake '%s' requires lock file changes but they're not allowed due to '--no-update-lock-file'",
+                                topRef);
 
                         auto newLockFileS = fmt("%s\n", newLockFile);
 
@@ -717,7 +774,8 @@ LockedFlake lockFlake(
 
                             topRef.input.putFile(
                                 CanonPath((topRef.subdir == "" ? "" : topRef.subdir + "/") + "flake.lock"),
-                                newLockFileS, commitMessage);
+                                newLockFileS,
+                                commitMessage);
                         }
 
                         /* Rewriting the lockfile changed the top-level
@@ -727,24 +785,21 @@ LockedFlake lockFlake(
                         FlakeCache dummyCache;
                         flake = getFlake(state, topRef, useRegistries, dummyCache);
 
-                        if (lockFlags.commitLockFile &&
-                            flake.lockedRef.input.getRev() &&
-                            prevLockedRef.input.getRev() != flake.lockedRef.input.getRev())
+                        if (lockFlags.commitLockFile && flake.lockedRef.input.getRev()
+                            && prevLockedRef.input.getRev() != flake.lockedRef.input.getRev())
                             warn("committed new revision '%s'", flake.lockedRef.input.getRev()->gitRev());
                     }
                 } else
-                    throw Error("cannot write modified lock file of flake '%s' (use '--no-write-lock-file' to ignore)", topRef);
+                    throw Error(
+                        "cannot write modified lock file of flake '%s' (use '--no-write-lock-file' to ignore)", topRef);
             } else {
                 warn("not writing modified lock file of flake '%s':\n%s", topRef, chomp(diff));
                 flake.forceDirty = true;
             }
         }
 
-        return LockedFlake {
-            .flake = std::move(flake),
-            .lockFile = std::move(newLockFile),
-            .nodePaths = std::move(nodePaths)
-        };
+        return LockedFlake{
+            .flake = std::move(flake), .lockFile = std::move(newLockFile), .nodePaths = std::move(nodePaths)};
 
     } catch (Error & e) {
         e.addTrace({}, "while updating the lock file of flake '%s'", flake.lockedRef.to_string());
@@ -752,9 +807,7 @@ LockedFlake lockFlake(
     }
 }
 
-std::pair<StorePath, Path> sourcePathToStorePath(
-    ref<Store> store,
-    const SourcePath & _path)
+std::pair<StorePath, Path> sourcePathToStorePath(ref<Store> store, const SourcePath & _path)
 {
     auto path = _path.path.abs();
 
@@ -767,9 +820,7 @@ std::pair<StorePath, Path> sourcePathToStorePath(
     return store->toStorePath(path);
 }
 
-void callFlake(EvalState & state,
-    const LockedFlake & lockedFlake,
-    Value & vRes)
+void callFlake(EvalState & state, const LockedFlake & lockedFlake, Value & vRes)
 {
     experimentalFeatureSettings.require(Xp::Flakes);
 
@@ -797,9 +848,7 @@ void callFlake(EvalState & state,
         auto key = keyMap.find(node);
         assert(key != keyMap.end());
 
-        override
-            .alloc(state.symbols.create("dir"))
-            .mkString(CanonPath(subdir).rel());
+        override.alloc(state.symbols.create("dir")).mkString(CanonPath(subdir).rel());
 
         overrides.alloc(state.symbols.create(key->second)).mkAttrs(override);
     }
@@ -821,16 +870,23 @@ void callFlake(EvalState & state,
 
 void initLib(const Settings & settings)
 {
-    auto prim_getFlake = [&settings](EvalState & state, const PosIdx pos, Value * * args, Value & v)
-    {
-        std::string flakeRefS(state.forceStringNoCtx(*args[0], pos, "while evaluating the argument passed to builtins.getFlake"));
+    auto prim_getFlake = [&settings](EvalState & state, const PosIdx pos, Value ** args, Value & v) {
+        std::string flakeRefS(
+            state.forceStringNoCtx(*args[0], pos, "while evaluating the argument passed to builtins.getFlake"));
         auto flakeRef = parseFlakeRef(state.fetchSettings, flakeRefS, {}, true);
         if (state.settings.pureEval && !flakeRef.input.isLocked())
-            throw Error("cannot call 'getFlake' on unlocked flake reference '%s', at %s (use --impure to override)", flakeRefS, state.positions[pos]);
+            throw Error(
+                "cannot call 'getFlake' on unlocked flake reference '%s', at %s (use --impure to override)",
+                flakeRefS,
+                state.positions[pos]);
 
-        callFlake(state,
-            lockFlake(settings, state, flakeRef,
-                LockFlags {
+        callFlake(
+            state,
+            lockFlake(
+                settings,
+                state,
+                flakeRef,
+                LockFlags{
                     .updateLockFile = false,
                     .writeLockFile = false,
                     .useRegistries = !state.settings.pureEval && settings.useRegistries,
@@ -840,7 +896,7 @@ void initLib(const Settings & settings)
     };
 
     RegisterPrimOp::primOps->push_back({
-        .name =  "__getFlake",
+        .name = "__getFlake",
         .args = {"args"},
         .doc = R"(
           Fetch a flake from a flake reference, and return its output attributes and some metadata. For example:
@@ -862,30 +918,27 @@ void initLib(const Settings & settings)
     });
 }
 
-static void prim_parseFlakeRef(
-    EvalState & state,
-    const PosIdx pos,
-    Value * * args,
-    Value & v)
+static void prim_parseFlakeRef(EvalState & state, const PosIdx pos, Value ** args, Value & v)
 {
-    std::string flakeRefS(state.forceStringNoCtx(*args[0], pos,
-        "while evaluating the argument passed to builtins.parseFlakeRef"));
+    std::string flakeRefS(
+        state.forceStringNoCtx(*args[0], pos, "while evaluating the argument passed to builtins.parseFlakeRef"));
     auto attrs = parseFlakeRef(state.fetchSettings, flakeRefS, {}, true).toAttrs();
     auto binds = state.buildBindings(attrs.size());
     for (const auto & [key, value] : attrs) {
         auto s = state.symbols.create(key);
         auto & vv = binds.alloc(s);
-        std::visit(overloaded {
-            [&vv](const std::string    & value) { vv.mkString(value); },
-            [&vv](const uint64_t       & value) { vv.mkInt(value);    },
-            [&vv](const Explicit<bool> & value) { vv.mkBool(value.t); }
-        }, value);
+        std::visit(
+            overloaded{
+                [&vv](const std::string & value) { vv.mkString(value); },
+                [&vv](const uint64_t & value) { vv.mkInt(value); },
+                [&vv](const Explicit<bool> & value) { vv.mkBool(value.t); }},
+            value);
     }
     v.mkAttrs(binds);
 }
 
 static RegisterPrimOp r3({
-    .name =  "__parseFlakeRef",
+    .name = "__parseFlakeRef",
     .args = {"flake-ref"},
     .doc = R"(
       Parse a flake reference, and return its exploded form.
@@ -906,15 +959,9 @@ static RegisterPrimOp r3({
     .experimentalFeature = Xp::Flakes,
 });
 
-
-static void prim_flakeRefToString(
-    EvalState & state,
-    const PosIdx pos,
-    Value * * args,
-    Value & v)
+static void prim_flakeRefToString(EvalState & state, const PosIdx pos, Value ** args, Value & v)
 {
-    state.forceAttrs(*args[0], noPos,
-        "while evaluating the argument passed to builtins.flakeRefToString");
+    state.forceAttrs(*args[0], noPos, "while evaluating the argument passed to builtins.flakeRefToString");
     fetchers::Attrs attrs;
     for (const auto & attr : *args[0]->attrs()) {
         auto t = attr.value->type();
@@ -922,22 +969,26 @@ static void prim_flakeRefToString(
             auto intValue = attr.value->integer().value;
 
             if (intValue < 0) {
-                state.error<EvalError>("negative value given for flake ref attr %1%: %2%", state.symbols[attr.name], intValue).atPos(pos).debugThrow();
+                state
+                    .error<EvalError>(
+                        "negative value given for flake ref attr %1%: %2%", state.symbols[attr.name], intValue)
+                    .atPos(pos)
+                    .debugThrow();
             }
 
             attrs.emplace(state.symbols[attr.name], uint64_t(intValue));
         } else if (t == nBool) {
-            attrs.emplace(state.symbols[attr.name],
-                Explicit<bool> { attr.value->boolean() });
+            attrs.emplace(state.symbols[attr.name], Explicit<bool>{attr.value->boolean()});
         } else if (t == nString) {
-            attrs.emplace(state.symbols[attr.name],
-                std::string(attr.value->string_view()));
+            attrs.emplace(state.symbols[attr.name], std::string(attr.value->string_view()));
         } else {
-            state.error<EvalError>(
-                "flake reference attribute sets may only contain integers, Booleans, "
-                "and strings, but attribute '%s' is %s",
-                state.symbols[attr.name],
-                showType(*attr.value)).debugThrow();
+            state
+                .error<EvalError>(
+                    "flake reference attribute sets may only contain integers, Booleans, "
+                    "and strings, but attribute '%s' is %s",
+                    state.symbols[attr.name],
+                    showType(*attr.value))
+                .debugThrow();
         }
     }
     auto flakeRef = FlakeRef::fromAttrs(state.fetchSettings, attrs);
@@ -945,7 +996,7 @@ static void prim_flakeRefToString(
 }
 
 static RegisterPrimOp r4({
-    .name =  "__flakeRefToString",
+    .name = "__flakeRefToString",
     .args = {"attrs"},
     .doc = R"(
       Convert a flake reference from attribute set format to URL format.
@@ -972,10 +1023,12 @@ static RegisterPrimOp r4({
 
 std::optional<Fingerprint> LockedFlake::getFingerprint(ref<Store> store) const
 {
-    if (lockFile.isUnlocked()) return std::nullopt;
+    if (lockFile.isUnlocked())
+        return std::nullopt;
 
     auto fingerprint = flake.lockedRef.input.getFingerprint(store);
-    if (!fingerprint) return std::nullopt;
+    if (!fingerprint)
+        return std::nullopt;
 
     *fingerprint += fmt(";%s;%s", flake.lockedRef.subdir, lockFile);
 
@@ -993,6 +1046,6 @@ std::optional<Fingerprint> LockedFlake::getFingerprint(ref<Store> store) const
     return hashString(HashAlgorithm::SHA256, *fingerprint);
 }
 
-Flake::~Flake() { }
+Flake::~Flake() {}
 
 }
diff --git a/src/libflake/flake/flake.hh b/src/libflake/flake/flake.hh
index cc2bea76e5..9d08a6ddaa 100644
--- a/src/libflake/flake/flake.hh
+++ b/src/libflake/flake/flake.hh
@@ -79,24 +79,37 @@ struct Flake
      * The original flake specification (by the user)
      */
     FlakeRef originalRef;
+
     /**
      * registry references and caching resolved to the specific underlying flake
      */
     FlakeRef resolvedRef;
+
     /**
      * the specific local store result of invoking the fetcher
      */
     FlakeRef lockedRef;
+
     /**
      * The path of `flake.nix`.
      */
     SourcePath path;
+
     /**
-     * pretend that 'lockedRef' is dirty
+     * Pretend that `lockedRef` is dirty.
      */
     bool forceDirty = false;
+
     std::optional<std::string> description;
+
     FlakeInputs inputs;
+
+    /**
+     * Attributes to be retroactively applied to the `self` input
+     * (such as `submodules = true`).
+     */
+    fetchers::Attrs selfAttrs;
+
     /**
      * 'nixConfig' attribute
      */
diff --git a/tests/functional/flakes/flake-in-submodule.sh b/tests/functional/flakes/flake-in-submodule.sh
index f98c19aa85..24ed08cbbb 100755
--- a/tests/functional/flakes/flake-in-submodule.sh
+++ b/tests/functional/flakes/flake-in-submodule.sh
@@ -77,6 +77,20 @@ git -C "$rootRepo" commit -m "Add flake.nix"
 storePath=$(nix flake metadata --json "$rootRepo?submodules=1" | jq -r .path)
 [[ -e "$storePath/submodule" ]]
 
+# Test the use of inputs.self.
+cat > "$rootRepo"/flake.nix <<EOF
+{
+  inputs.self.submodules = true;
+  outputs = { self }: {
+    foo = self.outPath;
+  };
+}
+EOF
+git -C "$rootRepo" commit -a -m "Bla"
+
+storePath=$(nix eval --raw "$rootRepo#foo")
+[[ -e "$storePath/submodule" ]]
+
 # The root repo may use the submodule repo as an input
 # through the relative path. This may change in the future;
 # see: https://discourse.nixos.org/t/57783 and #9708.
-- 
2.47.2

